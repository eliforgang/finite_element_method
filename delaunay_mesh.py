import numpy as np
import scipy.optimize
import scipy.spatial

def midPtCurve(f,fder,x1,x2): #midpoint of a curve segment, x1 x2 are endpoints
    integrand = lambda x: np.sqrt(1 + (fder(x))**2)
    L = gaussQuad1d(integrand,x1,x2,5)
    m = lambda x: gaussQuad1d(integrand,x1,x,5) - (L/2)
    xm = scipy.optimize.bisect(m,x1,x2)
    ym = f(xm)
    return xm, ym

def delaunayMesh(nodes): #mesh for quadrilateral domain {(x, y) | |x|+2|y| â‰¤ 4}. nodes is numpy array of (x,y) coordinates of nodes
    from scipy.spatial import Delaunay
    tri = Delaunay(nodes)
    triangles = tri.simplices
    for i in range(len(triangles)):
        for j in range(3):
            triangles[i,j] += 1
    edges = []
    edges_all = []
    for i in range(len(triangles)):
        edges_all.append([int(triangles[i,0]),int(triangles[i,1])])
        edges_all.append([int(triangles[i,1]),int(triangles[i,2])])
        edges_all.append([int(triangles[i,2]),int(triangles[i,0])])
        if [triangles[i,0],triangles[i,1]] not in edges and [triangles[i,1],triangles[i,0]] not in edges:
            edges.append([int(triangles[i,0]),int(triangles[i,1])])
        if [triangles[i,1],triangles[i,2]] not in edges and [triangles[i,2],triangles[i,1]] not in edges:
            edges.append([int(triangles[i,1]),int(triangles[i,2])])
        if [triangles[i,0],triangles[i,2]] not in edges and [triangles[i,2],triangles[i,0]] not in edges:
            edges.append([int(triangles[i,0]),int(triangles[i,2])])
    bdyNode = [False] * len(nodes)
    for i in range(len(nodes)):
        x = nodes[i,0]
        y = nodes[i,1]
        if abs(x) + 2*abs(y) == 4: #change this line for different domain
            bdyNode[i] = True
    bdyEdge = [False] * len(edges)
    for i in range(len(edges)):
        edgei = edges[i]
        edgei_backward = [edgei[1],edgei[0]]
        if edges_all.count(edgei) == 1 and edgei_backward not in edges_all:
            bdyEdge[i] = True
        if edges_all.count(edgei_backward) == 1 and edgei not in edges_all:
            bdyEdge[i] = True
    triangles=np.array(triangles) #numpy array of vertices of triangles generated by Delaunay
    edges=np.array(edges) #numpy array of vertices of every edge
    bdyNode=np.array(bdyNode) #numpy boolean array of if a node is a boundary node
    bdyEdge=np.array(bdyEdge) #numpy boolean array of if an edge is a boundary edge
    return triangles, edges, bdyNode, bdyEdge

##########################################################################

def gaussQuad1d(fn,lowerLimit,upperLimit,noOfIntegPt):
    import math
    g = lambda x: fn(upperLimit + ((upperLimit - lowerLimit)/2)*(x-1))
    if noOfIntegPt==2:
        y = ((upperLimit - lowerLimit)/2)*(g(-1/(math.sqrt(3))) + g(1/(math.sqrt(3))))
        return y
    elif noOfIntegPt==3:
        y = ((upperLimit - lowerLimit)/2)*((5/9)*g(-math.sqrt(3/5)) + (8/9)*g(0) + (5/9)*g(math.sqrt(3/5)))
        return y
    elif noOfIntegPt==4:
        y = ((upperLimit - lowerLimit)/2)*(((18-math.sqrt(30))/36)*g(-math.sqrt((3+(2*math.sqrt(6/5)))/7)) + 
                                          ((18+math.sqrt(30))/36)*g(-math.sqrt((3-(2*math.sqrt(6/5)))/7)) + 
                                          ((18+math.sqrt(30))/36)*g(math.sqrt((3-(2*math.sqrt(6/5)))/7)) +
                                          ((18-math.sqrt(30))/36)*g(math.sqrt((3+(2*math.sqrt(6/5)))/7)))
        return y
    elif noOfIntegPt==5:
        y = ((upperLimit - lowerLimit)/2)*(((322-(13*math.sqrt(70)))/900)*g(-(1/3)*math.sqrt(5+2*math.sqrt(10/7))) + 
                                           ((322+(13*math.sqrt(70)))/900)*g(-(1/3)*math.sqrt(5-2*math.sqrt(10/7))) +
                                           (128/225)*g(0) + 
                                           ((322+(13*math.sqrt(70)))/900)*g((1/3)*math.sqrt(5-2*math.sqrt(10/7))) +
                                           ((322-(13*math.sqrt(70)))/900)*g(math.sqrt((1/3)*math.sqrt(5+2*math.sqrt(10/7)))))
        return y
    else:
        print('Number of integers must be two, three, four, or five')